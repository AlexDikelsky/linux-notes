Awk := {{{
    Numbers and strings are built in
    Intended to be fast to write
    Looks like C, but no delcarations
    Good for testing a solution}}}
Chapter 1: An AWK tutorial {{{1
    1.1, Getting Started {{{2
	Use $1, $2, ..., to get the different lines
	Strucutre
	    pattern {action}
	    pattern {action}
	    ...
	
	Boolean operators:
	    ==, <, >
	
	Running a program
	    awk 'program' {input files}
	    awk 'program' {stdin}
	    awk -f program.awk {input files}  #-f stands for fetch
    }}}2
    1.2 Simple Output {{{2
	Do $0 to get the entire line.
	'{ print }' is the same as '{ print $0 }'
	Print last field sith $NF
	NF means "number of fields"
	NR mean "Line number"
	You can also do math in the print statment
	
    1.3 Fancier Output (printf){{{2
	You can also use standard printf stuff for nicer formating
	    printf(<format>, arg1, arg2, ..., argn)
    }}}2
    1.4 Selection {{{2
	Put conditions in the 'pattern' statment
	so that it only prints where some condition is true

	Use ||, &&, and ! for or, and, and not respectively
	This makes it easy to do data validation

	BEGIN and END
	BEGIN is an expression that matches before the 
	    first line of the first input
	END is an expression that matches after the 
	    last line of the last file

    }}}2
    1.5 Computing with AWK {{{2
	Action := A sequence of statments sepereated by newlines or semicolons.
	These are the things that are in the { }s
	You can create your own variables for calculations and storing data
	$3 > 15 { emp = emp + 1}
	END { print emp}
	prints total emps where $3 is greater than 15
	Note that END is a regex statment that 
	    matches the line after the end of input, 
	    and same kind of thing for BEGIN
	
	Awk makes it really convienient to handle text
	vars can hold strings.
	Concatonate files implicitly with "a" "b"

	There are builtin functions for nums like 
	    rand(), log(x) [natural log], sqrt(x)
	
	Also for strings 
	    length(s)
	Remeber to do length($0) for getting the length of a line
    }}}2
    1.6 Control-Flow Statments {{{2
	Used only in actions

	While loops are standard
	{ i = 0
	    while (i < 10) {
		print i
		i = i + 1
	    }
	}
	for a count from 0 to 9

	For loops are like java, so glorified while loops
	awk '
	{
	    for (i=0; i < 10; i=i+1) {
		print i
	    }
	}
	'

	does the same thing
    }}}2
    1.7 Arrays {{{2
	Seem to be associative arrays
	To add numbers, just do
	arr[location_to_add] = val
	Access with
	arr[location_to_add]
	Probably a good idea to start arrays at 1 here
    }}}2
    1.8 Useful one-liners (ish) {{{2 
	do `gf` on this oneliners_ch1.awk
    }}}2
}}}1
Chapter 2: The AWK language {{{1
    2.0 Introduction {{{2
	Everything is in terms of
	    pattern { action }
	    pattern { action }
	    ...
	statments
	You don't need a pattern always, and you don't need an action always
	For each pattern that matches the current input line, the action is executed
	    If no pattern is specified, then the action is always executed
	    If no action is specified, then it prints each input line matched by the pattern.
	Pattern == input line
	Opening line of an action must be on the same line as the pattern, ie
	    patt {
	    print }
	rather than 
	    patt
	    { print }
	Long statmenents can be split like this
	{ print \
	    $1,		#country name
	    $2,		#area
	    $3 }	#Pop in millions
    }}}2
    2.1 Patterns {{{2
	List {{{3
	1. BEGIN { statments }
	    statments executed once before any input is read
	2. END { statments }
	    statments executed once after all input has been read
	3. expression { statments }
	    statments are executed at each input line where expression is nonzero or nonnull
	4. /regex/    { statments }
	    executed at each input  line containing a string matched by /regex/
	5. compound pattern { statements }
	    executed where &&, ||, or ! are true, where &&, ||, and ! are and, or and not, respectively
	6. pattern1, pattern2 { statements }
	    range pattern. matches each input line from pat1 to pat 2, inclusive
	    stattments executed for each matching line
	}}}3
	BEGIN and END {{{3
	    Set initalization and cleanup stuff here, like FS = "\t", where FS is field seperator
	}}}3
	Expressions as Patterns {{{3
	    string      := is defined as a sequence of 0 or more characters.
	    null string := ""
	    substring   := contiguous sequence of 0 or more characters within a string
				The null string is a substring of any string between all characters, 
				and before the start and after the end
	    Any expression can be used as the operand of any operator
		If expression is numeric but operator needs a string
		    it will be converted to a string
		Strings will be autmaticly converted to numbers as well
	    Any expression can be used as a pattern. 
	    If expression has a nonzero or nonnull value at the current input line
		the pattern matches that line
	    Usually you compare something to something you want or don't want
	    The expressions are
		Operator    Meaning
		<	    less than
		<=	    less or equal
		==	    equal
		!=	    not equal
		>=	    greater or equal
		>	    greater
		~	matched by
		!~	not matched by

	    A string is considered to be 'greater' than another if it appears before it in a dictionary
	    $0 >= "y" return all strings that occur after y in the dictionary
	    Note that "Y" occurs before "y", so if you do 
		awk '$0 >= "Y"' american-english
	    you will get words that start with lowercase letters
	}}}3
	String-Matching Patterns {{{3
	    regular expression := notaion of specifying and matching strings of characters
	    A string-matching pattern tests if a string contains a substring matched by a regex
	    Note: 
		/Asia/ 
	    is short for 
		$0 ~ /Asia/
	    
	    {{{4
		Regular expression metacharacters
		Metacharacters are meta unless backslashed, ie
		    ".*"
		matches all strings
		    "[a-z]"
		matches lowercase letters
	    }}}4

	    Examples:
		/Asia/
		    Matches any string where Asia is a substing (Asia, Pan-Asiatic)
		$0 ~ "^.1.$" matches 010 and 011



	}}}3
    }}}2
    2.2 Actions {{{2
	Conditionals {{{3
	    expr1 ? expr2 : expr3
	    expr1 is evaluated. If expr is true, then
		evaluates to expr2
	    else
		evaluates to expr3
	}}}3
	Assignment: {{{3
	    ^, =, ++, --, +=, -=, % for modulus
	    do ++n rather than n++ because if you for 
	    some reason are doing
		f=n++
	    f will get the wrong value.
	}}}3
	Math {{{3
	Builtin math: 
	    atan2(y, x)
	    cos(x)
	    exp(x)
	    int(x) (like floor)
	    log(x) (natural log_
	    rand()  0 <= r < 1
	    sqrt(x)
	    srand(x)  random seed
	}}}
	Strings {{{3
	Builtin String operators:
	    Only concatonation implicitly, ie
		"a" ":" "b"
	    yelds
		a:b
	Strings as regex:
	    You can do
		BEGIN { digits = "^[0-9]+$" }
		$2 ~ digits
	    Remember to backslah backslashes in quotes
	Builtin String Functions 
	    gsub(r, s)	    sutstitute s for r in $0, returns matches
	    gsub(r, s, t)   same as other, but for t ranther than $0
	    length(s)	    len of s
	    index(s, t)	    returns leftmost position in str swhere 
			    t occurs. Return 0 if not found
	    match(s, r)	    returns leftmost position of longest
			    substr where the str begins, or
			    0 if not found
	    sub(r, s)	    substitute s for the leftmost
			    longest substring of $0 matched by r,
			    returns num substitutions made
	    sub(r,s,t)	    Same as sub but t instead of $0
	    substr(s,p,n)   return substr of s of len n
			    starting at position p
	Examples
	    { gsub(/a/, "new words", "$1"); print $0 }
	}}}3	
	Arrays {{{3
	    You don't need to declare arrays, or say how long the are going to be
	    They are associative arrays.
	    x[n], where n is a subscript, is actually a string rather than an integer
	    To get all the items, do 
		{ 
		for (item in array)
		    print item, array[item]
		}
	    You can delete elements with
		delete array[subscript]
	    Find inside with
		subscript in array
	}}}3
    }}}2
    2.3 Functions {{{2
	Creating functions:
	    function name(parameters) {
		statments
		<return expression>
	    }
	Max function:
	    function max(m, n) {
		return m > n ? m : n
	    }
	fib(x):
	    function fib(n) {
		return (n<2> ? n : (fib(n-2) + fib(n-1))
	    }
	Remember to declare these outside of curly braces
	When you pass a value like $1 to a function, it passes
	a copy rather than the actual thing, passed by value
	However, if you pass an array in, you can modify it.
	This is called by reference.

	EVERYTHING THAT IS NOT A PARAMETER IS A GLOBAL VARIABLE
    }}}2
    2.4 Output {{{2
	You can do 
	{ print >> newfile }
	inside an awk script
	You can change the ouput seperator to anything by doung
	    BEGIN { OFS = ":", ORS = "\n\n" }
	where OFS is between fields, and ORS is between lines
	read the printf manual
    }}}2
    2.5 Input {{{2
	Go back to the book if you need more help here
    }}}2
}}}1
Chapter 3: Data Processing {{{1
    3.1 Data Transformation and Reduction {{{2
	
    }}}2
}}}1
Chapter 6: Little Languages {{{1
    6.0 {{{2
	The general model for a programming lanugage is

	      source           ____________                ______________   Target
	-------------------->  | analyzer | -------------> | sythesizer | ----------->
	     program           ------------                --------------   program
	                             \     ______________      /
				       ----|Symbol Table|------
				           --------------

	analyzer := Front end tool that reads source, breaks into operators and operands
		    Checks that program is grammaticly correct, and can send compile time errors
		    Then translates source to an intermidiate representation to give to the back-end, or the synthesier
	syntheysiser := Back end tool to actually run the program
	Symbol Table := Communicates info collected by the analyzer about the source to the synth.
    }}}2
    6.1 An Assembler and Interpreter {{{2
	Creating a computer that has:
	    a single accumulator
	    ten instructions
	    word-addressable memorty of 1000 words
		a word holds 5 decimal digits
		    If a word is an inscruction, 
			the first 2 digits hold the instruction,
			and the last 3 hold the address.

	    Instructions {{{4
	    OPCODE  INSTRUCTION	MEANING
	    01	    get		read a number from input into accumulator
	    02	    put		write contents of accumulator to output
	    03	    ld M	load accumulator with contents of mem location M
	    04	    st M	store contents of accumulator in location M
	    05	    add M	add contents of location M to accumulator
	    06	    sub M	subtract conditions of location M to accumulator
	    07	    jpos M	jump to location M if accumulator is positive
	    08	    jz M	jump to location M if accumulator is zero
	    09	    j M		jump to location M
	    10	    halt	stop execution
		
		    const C	assembeler pseud-operation to define constant C
	    }}}4

	An assembely-lanugage program is a sequence of statments, each consisting of
	    a lable, operation, and operand
	Any fields may be empty
	Examples {{{4
	    #This sums the first 2 numbers typed in
	    #Command  Location
	    get
	    st 001
	    get
	    add 001
	    put
	    halt

	    #This sums all numbers typed in until 0 is typed
	    ld zero     #Start stuff at 0
	    st sum   #Start stuff at 0
    loop    get
	    jz END
	    add sum
	    st sum
	    j loop
    
    done    ld sum
	    put 
	    halt
    zero    const 0
    sum	    const
	It's kinda hard to translate this to machine code by hand, so you get something to run it, like awk
 0:  03010	    ld zero     #Start stuff at 0
 1:  04011	    st sum   #Start stuff at 0
 2:  01000    loop  get
 3:  08007	    jz END
 4:  05011	    add sum
 5:  04011	    st sum
 6:  09002	    j loop
 7:  03011    done  ld sum
 8:  02000    	    put 
 9:  10000	    halt 
10:  00000    zero  const 0  
11:  00000    sum   const

    The first field is the mem location
    second is the encoded instruction

    Memorty location 0 contains the translation of the first instruction of the program, ld zero

    The assembler does this tranlation in 2 passes:
	Pass 1: 
	    field split to do lexical/syntactic analysis
	    reads, discards comments, assigns memory locations, writes intermidiate represetation to temp file
	Pass 2:
	    reads temp file, converts symbolic operands to mem locations
    
    Then you need an interprater to actually run the commands
	loop that fetches instructions from mem, and decodes it
	The program counter is in variable pc


	
	




	    
    }}}2




}}}1


